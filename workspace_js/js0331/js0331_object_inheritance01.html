<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>클래스 기본 2 - 상속</title>
  <script>
    /*
    상속 (inheritance)
    - 부모 클래스의 프로퍼티와 메소드를 받아서 자식 클래스에서 사용할 수 있도록 하는 것

    상속을 하는 이유
    - 중복된 프로퍼티와 메소드 부모에서 상속하도록 구현하여, 관리(유지보수)와 처리의 효율성을 높이기 위한 방법
    */

    // 직사각형 클래스
    class Rectangle {
      // 생성자
      constructor(width, height) {
        this.width = width
        this.height = height
      }
      // 둘레를 구하는 메소드
      getPerimeter() {
        return (this.width + this.height) * 2
      }
      // 면적을 구하는 메소드
      getArea() {
        return this.width * this.height
      }
    }

    // 정사각형 클래스
    // 문제점 : 프로퍼티와 메소드가 Rectangle 클래스와 완전히 일치하여, 관리의 유지보수, 효율성, 재활용성이 좋지 않음.
    // 해결책 : Square 클래스를 Rectaangle 클래스로 부터 상속하도록 함.
    /* Rectangle 클래스로부터 상속을 하지 않은 Square 클래스
    class Square {
      // 생성자 
      constructor(width, height) {
        this.width = width
        this.height = height
      }
      // 둘레를 구하는 메소드
      getPerimeter() {
        return (this.width + this.height) * 2
      }
      // 면적을 구하는 메소드
      getArea() {
        return this.width * this.height
      }
    }
    */

    // Rectangle 클래스로부터 상속된 Square 클래스
    // super() : 부모 클래스의 생성자를 호출하는 방법
    // Square 클래스는 부모인 Rectangle 클래스의 모든 자원을 사용할 수 있음.
    class Square extends Rectangle {
      constructor(length) {
        if (length < 0) {
          throw "길이는 0보다 커야 합니다."
        }
        super(length, length)
      }
    }

    let r1 = new Rectangle(20, 10)
    console.log(`직사각형의 둘레 : ${r1.getPerimeter()}, 직사각형 면적 : ${r1.getArea()}`);

    let s1 = new Square(30)
    console.log(`정사각형의 둘레 : ${s1.getPerimeter()}, 정사각형 면적 : ${s1.getArea()}`);

    // let s2 = new Square(-10)
    let s2 = new Square(10)
    s2.width = -15 // 예외처리로도 막지 못함.
    console.log(`정사각형의 둘레 : ${s2.getPerimeter()}, 정사각형 면적 : ${s2.getArea()}`);


  </script>
</head>

<body>

</body>

</html>