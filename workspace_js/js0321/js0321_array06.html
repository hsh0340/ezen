<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>배열 응용과제 1
    <!-- 
      과제3) 
    Math.random() :  0~1 미만의 난수를 발생, 0 ~ 0.9999999.... 를 난수로 발생
    Math.random() * 10 -> 0 ~ 9.999999... 를 난수로 발생
    parseInt(Math.random() * 10) -> 0 ~ 9 사이의 정수를 난수로 발생
    parseInt(Math.random() * 10) + 1-> 0 ~ 10 사이의 정수를 난수로 발생

    scores라는 1차원 배열에 10~99 사이의 두자리 난수를 20개 만들어서 저장하고,
    scores 1차원 배열을 오름차순과 내림차순으로 정렬하여 출력하시오.
    출력할 때는 1가지 반복문을 사용하여 출력하시오.
     -->
    <script>
      // 과제 3-1번
      function quiz03_1() {
        let n = Number(prompt("정렬할 정수의 개수를 입력하시오."));
        let a = [];

        // 2자리의 난수를 n개 발생하여 배열에 저장, 10 ~ 99
        // Math.random() : 0 ~ 0.9999....
        // Math.random() * 90 : 0 ~ 89.9999....
        // parsaeInt(Math.random() * 90) + 10 : 10 ~ 99
        for (let i = 0; i < n; i++) {
          a[i] = parseInt(Math.random() * 90) + 10;
        }
        console.log(a);

        // 정렬 순서에 의한 방법: 오름차순, 내림차순
        // 오름차순 정렬(ascending sort) : 작은 값부터 큰 값으로 출력 
        // 내림차순 정렬(descending sort) : 큰 값부터 작은 값으로 출력

        // 정렬 기법에 의한 방법: 선택정렬(selection sort) , 버블정렬(bubble sort)

        // 1번 - 선택정렬: i(나)가 j(상대)를 1씩 증가하여 선택하면서 비교하는 방법
        for (let i = 0; i < a.length - 1; i++) { // i: 각각의 나
          for (let j = i + 1; j < a.length; j++) { // j: 비교대상
            if (a[i] > a[j]) { // 내가 상대보다 크다면 교환: 오름차순, 내가 상대보다 작다면 교환: 내림차순
              let t = a[i];
              a[i] = a[j];
              a[j] = t;
            }
          }
        }
        console.log("선택정렬 후 : " + a);
      }

      // 과제 3-2번
      function quiz03_2() {
        let n = Numver(prompt("정렬할 정수의 개수를 입력하시오."));
        let a = new Array();

        for (let i = 0; i < n; i++) {
          a[i] = parseInt(Math.random() * 90) + 10;
        }
        console.log("버블정렬 전 : " + a);

        // 2번 - 버블정렬(bubble sort) : 인접한 데이터 2개(j와 j+1)를 비교하는 방법
        // 버블정렬에서는 인접하는 두개의 값을 비교함으로써 flag기법을 사용하여 효율을 더 높일 수 있음
        // - 정렬이 이미 끝난 상태를 체크하여 반복을 끝내도록 설정하는 방법
        // - 선택정렬에서는 flag를 사용불가
        for (let i = 0; i < a.length - 1; i++) { // i: 횟수를 제어하는 역할
          let flag = false;
          for (let j = 0; j < a.length - 1 - i; j++) { // 인접한 2개의 값을 비교(j와 j+1)
            if (a[j] > a[j + 1]) { // >: 오름차순, <: 내림차순
              let t = a[j];
              a[j] = a[j + 1];
              a[j + 1] = t;
              flag = true;
            }
          }
          if (flag = false) break;
          console.log(i + "회정렬 후" + a);
        }
        console.log("버블정렬 후 : " + a);
      }
    </script>
  </title>
</head>

<body>
  <h3>과제 3번</h3>
  <p>
    scores라는 1차원 배열에 10~99 사이의 두자리 난수를 20개 만들어서 저장하고,
    scores 1차원 배열을 오름차순과 내림차순으로 정렬하여 출력하시오.
    출력할 때는 1가지 반복문을 사용하여 출력하시오.</p>
  <button onclick="quiz03_1()">실행</button>
  <button onclick="quiz03_2()">실행</button>
</body>

</html>